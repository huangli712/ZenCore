#
# Project : Pansy
# Source  : dmft.jl
# Author  : Li Huang (lihuang.dmft@gmail.com)
# Status  : Unstable
#
# Last modified: 2021/06/07
#

#
# Driver Functions
#

"""
    dmft_init(it::IterInfo, task::I64)

Initialize the dynamical mean-field theory engine. Prepare the necessary
files, and generate the configuration file.

See also: [`dmft_exec`](@ref), [`dmft_save`](@ref).
"""
function dmft_init(it::IterInfo, task::I64)
    # Check the task
    @assert task in (1, 2)

    # Well, determine which files are necessary. They are defined in
    # `fsig`, `fir1`, `fir2`, and `fdmft`.
    #
    # Self-energy functions and their double counting terms
    fsig = ["sigma.bare", "sigma.dc"]
    #
    # Parameter sets within the IR format
    fir1 = ["params.ir", "maps.ir", "groups.ir", "windows.ir"]
    #
    # Kohn-Sham data within the IR format
    fir2 = ["lattice.ir", "kmesh.ir", "eigen.ir", "projs.ir"]
    #
    # Tetrahedron data are available
    if get_d("smear") === "tetra"
        push!(fir2, "tetra.ir")
    end
    #
    # Main control file for the DMFT engine
    fdmft = ("dmft.in")

    # Next, we have to copy Kohn-Sham data from `dft` to `dmft1`.
    foreach( x ->
        begin
            file_src = joinpath("../dft", x)
            file_dst = x
            cp(file_src, file_dst, force = true)
        end,
    union(fir1, fir2) )

    # Extract key parameters, which should be written into the `dmft.in`.
    axis = get_m("axis")
    beta = get_m("beta")
    mc = ( get_m("mc") isa Missing ? 0.001 : get_m("mc") )
    lfermi = ( get_m("lfermi") isa Missing ? true : get_m("lfermi") )
    ltetra = ( get_d("smear") === "tetra" )

    # Generate essential input files, such as dmft.in, dynamically.
    # If the `dmft.in` file exists already, it will be overwritten.
    open("dmft.in", "w") do fout
        println(fout, "task = $task")
        println(fout, "axis = $axis")
        println(fout, "beta = $beta")
        println(fout, "mc   = $mc")
        println(fout, "lfermi = $lfermi")
        println(fout, "ltetra = $ltetra")
    end

    # Check essential input files
    flist = (fdmft, fsig..., fir1..., fir2...)
    for i in eachindex(flist)
        filename = flist[i]
        if !isfile(filename)
            error("Please make sure the file $filename is available")
        end
    end
end

"""
    dmft_exec(it::IterInfo, task::I64)

Execute the dynamical mean-field theory engine.

See also: [`dmft_init`](@ref), [`dmft_save`](@ref).
"""
function dmft_exec(it::IterInfo, task::I64)
    # Check the task
    @assert task in (1, 2)

    # Print the header
    println("Engine : DMFT$(subscript(task))")

    # Get the home directory of DMFT engine
    dmft_home = query_dmft()

    # Determine mpi prefix (whether the dmft is executed sequentially)
    mpi_prefix = inp_toml("../MPI.toml", "dmft", false)
    numproc = parse(I64, line_to_array(mpi_prefix)[3])
    println("  Para : Using $numproc processors")

    # Select suitable dmft program
    dmft_exe = "$dmft_home/dmft"
    @assert isfile(dmft_exe)
    println("  Exec : $dmft_exe")

    # Assemble command
    if isnothing(mpi_prefix)
        dmft_cmd = dmft_exe
    else
        dmft_cmd = split("$mpi_prefix $dmft_exe", " ")
    end

    # Launch it, the terminal output is redirected to dmft.out
    run(pipeline(`$dmft_cmd`, stdout = "dmft.out"))

    # Print the footer for a better visualization
    println()
end

"""
    dmft_save(it::IterInfo, task::I64)

Backup the files outputed by the dynamical mean-field theory engine.

See also: [`dmft_init`](@ref), [`dmft_exec`](@ref).
"""
function dmft_save(it::IterInfo, task::I64)
    # Check the task
    @assert task in (1, 2)

    # Create a list of files that need to be backup
    fdmf1 = ["dmft.out"]
    fdmf2 = ["dmft.eimps", "dmft.eimpx", "dmft.fermi"]
    fdmf3 = ["dmft.grn_l", "dmft.hyb_l", "dmft.wss_l"]

    # Be careful, the final file list depends on the task
    if task == 1
        file_list = union(fdmf1, fdmf2, fdmf3)
    else
        file_list = fdmf1
    end

    # Store the data files
    for i in eachindex(file_list)
        f = file_list[i]
        cp(f, "$f.$(it.I₃).$(it.I₁)", force = true)
    end

    # Extract the fermi level, and use it to update the IterInfo struct.
    it.μ₁ = read_fermi()
end

#
# Service Functions: For I/O Operations
#

"""
    read_fermi()

Parse the dmft1/dmft.fermi file to extract the chemical potential.

See also: [`dmft_save`](@ref).
"""
function read_fermi()
    fname = "dmft.fermi"
    fermi = 0.0

    if isfile(fname)
        str = readline("dmft.fermi")
        fermi = parse(F64, line_to_array(str)[3])
    end

    return fermi
end

#
# Service Functions: For I/O Operations
#

"""
    read_delta(imp::Impurity)

Extract hybridization functions from `impurity.i/dmft.hyb_l` file, which
is generated by `sigma_split()`. These data are essential for quantum
impurity solvers. The working directory of this function must be equal
to `impurity.i`.

The frequency mesh is also extracted in this function.

See also: [`Impurity`](@ref), [`read_eimpx`](@ref).
"""
function read_delta(imp::Impurity)
    # Get index of the quantum impurity problem
    index = imp.index

    # Get number of orbitals for the quantum impurity problem
    nband = imp.nband

    # Examine the current directory
    dirname = basename(pwd())
    dirvect = split(dirname, ".")
    @assert dirvect[1] == "impurity"
    @assert parse(I64, dirvect[2]) == index

    # Declare empty arrays for frequency mesh and hybridization functions
    fmesh = nothing
    Delta = nothing

    # Parse the `impurity.i/dmft.hyb_l` file
    open("dmft.hyb_l", "r") do fin
        # Get the dimensional parameters
        nsite = parse(I64, line_to_array(fin)[3])
        nspin = parse(I64, line_to_array(fin)[3])
        nmesh = parse(I64, line_to_array(fin)[3])
        qdim  = parse(I64, line_to_array(fin)[4])
        @assert nsite ≥ 1
        @assert qdim ≥ nband

        # Skip two lines
        readline(fin)
        readline(fin)

        # Create an array for frequency mesh
        fmesh = zeros(F64, nmesh)

        # Create an array for hybridization functions
        Delta = zeros(C64, nband, nband, nmesh, nspin)

        # Go through each spin orientation
        for s = 1:nspin
            # Analyze the important parameters
            strs = readline(fin)
            _t = parse(I64, line_to_array(strs)[3])
            _s = parse(I64, line_to_array(strs)[5])
            _d = parse(I64, line_to_array(strs)[7])
            @assert _t == index
            @assert _s == s
            @assert _d == nband

            # Go through each frequency point
            for m = 1:nmesh
                # Extract frequency
                fmesh[m] = parse(F64, line_to_array(fin)[3])

                # Parse the hybridization functions
                for q = 1:nband
                    for p = 1:nband
                        _re, _im = parse.(F64, line_to_array(fin)[3:4])
                        Delta[p,q,m,s] = _re + _im * im
                    end
                end
            end # END OF M LOOP

            # Skip two lines
            readline(fin)
            readline(fin)
        end # END OF S LOOP
    end # END OF IOSTREAM

    # Return the desired arrays
    return fmesh, Delta
end

"""
    read_delta(ai::Array{Impurity,1}, fhyb::String = "dmft1/dmft.hyb_l")

Read the `dmft1/dmft.hyb_l` file, extract the hybridization functions Δ
and the corresponding frequency mesh ω. The working directory of this
function must be the root folder.

See also: [`sigma_split`](@ref), [`read_eimpx`](@ref).
"""
function read_delta(ai::Array{Impurity,1}, fhyb::String = "dmft1/dmft.hyb_l")
    # Declare the frequency mesh and hybridization function
    fmesh = []
    Delta = []

    # Make sure the existence of hybridization functions
    @assert isfile(fhyb)

    # Parse `fhyb`, extract the hybridization functions
    open(fhyb, "r") do fin
        # Get the dimensional parameters
        nsite = parse(I64, line_to_array(fin)[3])
        nspin = parse(I64, line_to_array(fin)[3])
        nmesh = parse(I64, line_to_array(fin)[3])
        qdim  = parse(I64, line_to_array(fin)[4])
        @assert nsite == length(ai)

        # Skip two lines
        readline(fin)
        readline(fin)

        # Create an array for frequency mesh
        fmesh = zeros(F64, nmesh)

        # Create an array for hybridization functions
        Delta = zeros(C64, qdim, qdim, nmesh, nspin, nsite)

        # Read the data
        # Go through each quantum impurity site and spin
        for t = 1:nsite
            for s = 1:nspin
                # Parse indices and dimensional parameter
                strs = readline(fin)
                _t = parse(I64, line_to_array(strs)[3])
                _s = parse(I64, line_to_array(strs)[5])
                _d = parse(I64, line_to_array(strs)[7])
                @assert _t == t
                @assert _s == s
                @assert _d == ai[t].nband

                # Go through each frequency point
                for m = 1:nmesh
                    # Parse frequency mesh
                    fmesh[m] = parse(F64, line_to_array(fin)[3])
                    # Parse hybridization functions
                    for q = 1:ai[t].nband
                        for p = 1:ai[t].nband
                            _re, _im = parse.(F64, line_to_array(fin)[3:4])
                            Delta[p,q,m,s,t] = _re + _im * im
                        end
                    end
                end # END OF M LOOP

                # Skip two lines
                readline(fin)
                readline(fin)
            end # END OF S LOOP
        end # END OF T LOOP
    end # END OF IOSTREAM
    println("  Read hybridization functions from: $fhyb")

    # Return the desired arrays
    return fmesh, Delta
end

#
# Service Functions: For I/O Operations
#

"""
    read_eimpx(imp::Impurity)

Extract local impurity levels from `impurity.i/dmft.eimpx` file, which
is generated by `sigma_split()`. These data are essential for quantum
impurity solvers. The working directory for this function must be equal
to `impurity.i`.

See also: [`Impurity`](@ref), [`read_delta`](@ref).
"""
function read_eimpx(imp::Impurity)
    # Get index of the quantum impurity problem
    index = imp.index

    # Get number of orbitals for the quantum impurity problem
    nband = imp.nband

    # Examine the current directory
    dirname = basename(pwd())
    dirvect = split(dirname, ".")
    @assert dirvect[1] == "impurity"
    @assert parse(I64, dirvect[2]) == index

    # Declare an empty array for local impurity levels
    Eimpx = nothing

    # Parse the `dmft.eimpx` file
    open("dmft.eimpx", "r") do fin
        # Get the dimensional parameters
        nsite = parse(I64, line_to_array(fin)[3])
        nspin = parse(I64, line_to_array(fin)[3])
        qdim  = parse(I64, line_to_array(fin)[4])
        @assert nsite ≥ 1
        @assert qdim ≥ nband

        # Skip two lines
        readline(fin)
        readline(fin)

        # Create an array for local impurity levels
        Eimpx = zeros(C64, nband, nband, nspin)

        # Go through each spin orientation
        for s = 1:nspin
            # Analyze the important parameters
            strs = readline(fin)
            _t = parse(I64, line_to_array(strs)[3])
            _s = parse(I64, line_to_array(strs)[5])
            _d = parse(I64, line_to_array(strs)[7])
            @assert _t == index
            @assert _s == s
            @assert _d == nband

            # Parse local impurity levels
            for q = 1:nband
                for p = 1:nband
                    _re, _im = parse.(F64, line_to_array(fin)[3:4])
                    Eimpx[p,q,s] = _re + _im * im
                end
            end

            # Skip two lines
            readline(fin)
            readline(fin)
        end # END OF S LOOP
    end # END OF IOSTREAM

    # Return the desired array
    return Eimpx
end

"""
    read_eimpx(ai::Array{Impurity,1}, flev::String = "dmft1/dmft.eimpx")

Read the `dmft1/dmft.eimpx` file, extract the local impurity levels εᵢ. The
working directory of this function must be the root folder.

See also: [`sigma_split`](@ref), [`read_delta`](@ref).
"""
function read_eimpx(ai::Array{Impurity,1}, flev::String = "dmft1/dmft.eimpx")
    # Declare the local impurity levels
    Eimpx = []

    # Make sure the existence of local impurity levels
    @assert isfile(flev)

    # Parse `flev`, extract the local impurity levels
    open(flev, "r") do fin
        # Get the dimensional parameters
        nsite = parse(I64, line_to_array(fin)[3])
        nspin = parse(I64, line_to_array(fin)[3])
        qdim  = parse(I64, line_to_array(fin)[4])
        @assert nsite == length(ai)

        # Skip two lines
        readline(fin)
        readline(fin)

        # Create an array for local impurity levels
        Eimpx = zeros(C64, qdim, qdim, nspin, nsite)

        # Read the data
        # Go through each quantum impurity site and spin
        for t = 1:nsite
            for s = 1:nspin
                # Parse indices and dimensional parameter
                strs = readline(fin)
                _t = parse(I64, line_to_array(strs)[3])
                _s = parse(I64, line_to_array(strs)[5])
                _d = parse(I64, line_to_array(strs)[7])
                @assert _t == t
                @assert _s == s
                @assert _d == ai[t].nband

                # Parse local impurity levels
                for q = 1:ai[t].nband
                    for p = 1:ai[t].nband
                        _re, _im = parse.(F64, line_to_array(fin)[3:4])
                        Eimpx[p,q,s,t] = _re + _im * im
                    end
                end

                # Skip two lines
                readline(fin)
                readline(fin)
            end # END OF S LOOP
        end # END OF T LOOP
    end # END OF IOSTREAM
    println("  Read local impurity levels from: $flev")

    # Return the desired array
    return Eimpx
end

#
# Service Functions: For I/O Operations
#

"""
    write_delta(fmesh::Array{F64,1}, Delta::Array{C64,5}, ai::Array{Impurity,1})

Split hybridization functions and the corresponding frequency mesh into
the `impurity.i/dmft.hyb_l` file, which is essential for the quantum
impurity solver. The working directory of this function must be the
root folder.

See also: [`Impurity`](@ref), [`read_delta`](@ref), [`write_eimpx`](@ref).
"""
function write_delta(fmesh::Array{F64,1}, Delta::Array{C64,5}, ai::Array{Impurity,1})
   # Extract the dimensional parameters
    _, qdim, nmesh, nspin, nsite = size(Delta)

    # Go through each quantum impurity problem
    for t = 1:nsite
        # Determine filename for hybridization functions
        fhyb = "impurity.$t/dmft.hyb_l"

        # Write the data
        open(fhyb, "w") do fout
            # Write dimensional parameters
            @printf(fout, "# nsite: %4i\n", nsite)
            @printf(fout, "# nspin: %4i\n", nspin)
            @printf(fout, "# nmesh: %4i\n", nmesh)
            @printf(fout, "# qdim : %4i\n", qdim)

            # Write separators
            println(fout)
            println(fout)

            # Go through each spin
            for s = 1:nspin
                # Write key parameters
                @printf(fout, "# site:%4i  spin:%4i  dims:%4i\n", t, s, ai[t].nband)

                # Go through each frequency point
                for m = 1:nmesh
                    @printf(fout, "w:%6i%16.8f\n", m, fmesh[m])
                    # Go through the orbital space
                    for q = 1:ai[t].nband
                        for p = 1:ai[t].nband
                            z = Delta[p,q,m,s,t]
                            @printf(fout, "%4i%4i%16.8f%16.8f\n", p, q, real(z), imag(z))
                        end
                    end
                end # END OF M LOOP

                # Write separators
                println(fout)
                println(fout)
            end # END OF S LOOP
        end # END OF IOSTREAM

        # Print message to the screen
        println("  Split hybridization functions into: $fhyb")
    end # END OF T LOOP
end

"""
    write_delta(fmesh::Array{F64,1}, Delta::Array{C64,5}, ai::Array{Impurity,1}, fhyb::String)

Write hybridization functions into the `fhyb` file. This function is usually
called by `mixer_delta()` to update the `dmft1/dmft.hyb_l` file. The working
directory of this function must be the root folder.

See also: [`Impurity`](@ref), [`read_delta`](@ref), [`write_eimpx`](@ref).
"""
function write_delta(fmesh::Array{F64,1}, Delta::Array{C64,5}, ai::Array{Impurity,1}, fhyb::String)
    # Extract the dimensional parameters
    _, qdim, nmesh, nspin, nsite = size(Delta)

    # Determine filename for hybridization functions
    @assert fhyb == "dmft1/dmft.hyb_l"

    # Write the data
    open(fhyb, "w") do fout
        # Write dimensional parameters
        @printf(fout, "# nsite: %4i\n", nsite)
        @printf(fout, "# nspin: %4i\n", nspin)
        @printf(fout, "# nmesh: %4i\n", nmesh)
        @printf(fout, "# qdim : %4i\n", qdim)

        # Write separators
        println(fout)
        println(fout)

        # Go through each quantum impurity problem
        for t = 1:nsite
            # Go through each spin
            for s = 1:nspin
                # Write key parameters
                @printf(fout, "# site:%4i  spin:%4i  dims:%4i\n", t, s, ai[t].nband)

                # Go through each frequency point
                for m = 1:nmesh
                    @printf(fout, "w:%6i%16.8f\n", m, fmesh[m])
                    # Go through the orbital space
                    for q = 1:ai[t].nband
                        for p = 1:ai[t].nband
                            z = Delta[p,q,m,s,t]
                            @printf(fout, "%4i%4i%16.8f%16.8f\n", p, q, real(z), imag(z))
                        end
                    end
                end # END OF M LOOP

                # Write separators
                println(fout)
                println(fout)
            end # END OF S LOOP
        end # END OF T LOOP
    end # END OF IOSTREAM

    # Print message to the screen
    println("  Write hybridization functions into: $fhyb")
end

#
# Service Functions: For I/O Operations
#

"""
    write_eimpx(Eimpx::Array{C64,4}, ai::Array{Impurity,1})

Split local impurity levels into the `impurity.i/dmft.eimpx` file, which
is essential for the quantum impurity solver. The working directory of
this function must be the root folder.

See also: [`Impurity`](@ref), [`read_eimpx`](@ref), [`write_delta`](@ref).
"""
function write_eimpx(Eimpx::Array{C64,4}, ai::Array{Impurity,1})
    # Extract the dimensional parameters
    _, qdim, nspin, nsite = size(Eimpx)

    # Go through each quantum impurity problems
    for t = 1:nsite
        # Determine filename for local impurity levels
        flev = "impurity.$t/dmft.eimpx"

        # Write the data
        open(flev, "w") do fout
            # Write dimensional parameters
            @printf(fout, "# nsite: %4i\n", nsite)
            @printf(fout, "# nspin: %4i\n", nspin)
            @printf(fout, "# qdim : %4i\n", qdim)

            # Write separators
            println(fout)
            println(fout)

            # Go through each spin
            for s = 1:nspin
                # Write key parameters
                @printf(fout, "# site:%4i  spin:%4i  dims:%4i\n", t, s, ai[t].nband)

                # Go through the orbital space
                for q = 1:ai[t].nband
                    for p = 1:ai[t].nband
                        z = Eimpx[p,q,s,t]
                        @printf(fout, "%4i%4i%16.8f%16.8f\n", p, q, real(z), imag(z))
                    end
                end

                # Write separators
                println(fout)
                println(fout)
            end # END OF S LOOP
        end # END OF IOSTREAM

        # Print message to the screen
        println("  Split local impurity levels into: $flev")
    end # END OF T LOOP
end

"""
    write_eimpx(Eimpx::Array{C64,4}, ai::Array{Impurity,1}, flev::String)

Write local impurity levels into the `flev` file. This function is usually
called by `mixer_eimpx()` to update the `dmft1/dmft.eimpx` file. The
working directory of this function must be the root folder.

See also: [`Impurity`](@ref), [`read_eimpx`](@ref), [`write_delta`](@ref).
"""
function write_eimpx(Eimpx::Array{C64,4}, ai::Array{Impurity,1}, flev::String)
    # Extract the dimensional parameters
    _, qdim, nspin, nsite = size(Eimpx)

    # Determine filename for local impurity levels
    @assert flev == "dmft1/dmft.eimpx"

    # Write the data
    open(flev, "w") do fout
        # Write dimensional parameters
        @printf(fout, "# nsite: %4i\n", nsite)
        @printf(fout, "# nspin: %4i\n", nspin)
        @printf(fout, "# qdim : %4i\n", qdim)

        # Write separators
        println(fout)
        println(fout)

        # Go through each quantum impurity problems
        for t = 1:nsite
            # Go through each spin
            for s = 1:nspin
                # Write key parameters
                @printf(fout, "# site:%4i  spin:%4i  dims:%4i\n", t, s, ai[t].nband)

                # Go through the orbital space
                for q = 1:ai[t].nband
                    for p = 1:ai[t].nband
                        z = Eimpx[p,q,s,t]
                        @printf(fout, "%4i%4i%16.8f%16.8f\n", p, q, real(z), imag(z))
                    end
                end

                # Write separators
                println(fout)
                println(fout)
            end # END OF S LOOP
        end # END OF T LOOP
    end # END OF IOSTREAM

    # Print message to the screen
    println("  Write local impurity levels into: $flev")
end
